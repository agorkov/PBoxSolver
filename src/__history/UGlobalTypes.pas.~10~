unit UGlobalTypes;

interface

uses
  Vcl.Graphics;

type
  TECellType = (ctEmpty, ctAinable, ctWall, ctBox, ctBoxPlace, ctHome);

  TCMap = class
  private
    mapH, mapW: integer;
    map: array of array of set of TECellType;
  public
    procedure LoadMapFromFile(FileName: string);
    function DrawMap: TBitmap;
  end;

implementation

uses
  UColorImages;

procedure TCMap.LoadMapFromFile(FileName: string);
var
  f: TextFile;
  I: Integer;
  j: Integer;
  t: AnsiChar;
begin
  AssignFile(f, FileName);
  Reset(f);
  Read(f, Self.mapH);
  SetLength(self.map, Self.mapH + 1);
  Readln(f, Self.mapW);
  for I := 1 to Self.mapH do
    SetLength(Self.map[I], Self.mapW + 1);
  for I := 1 to Self.mapH do
    for j := 1 to Self.mapW do
      self.map[I, j] := [ctEmpty];
  while not Eof(f) do
  begin
    read(f, I);
    read(f, j);
    read(f,t);
    Readln(f, t);
    case t of
      'H':
        map[I, j] := map[I, j] + [ctHome];
      'I':
        map[I, j] := map[I, j] + [ctAinable];
      'W':
        map[I, j] := map[I, j] + [ctWall];
      'B':
        map[I, j] := map[I, j] + [ctBox];
      'P':
        map[I, j] := map[I, j] + [ctBoxPlace];
    end;
  end;
  CloseFile(f);
end;

function TCMap.DrawMap: TBitmap;
var
  CI: UcolorImages.TCColorImage;
  i: Integer;
  j: Integer;
begin
  CI := TCColorImage.Create;
  CI.Height := mapH;
  CI.Width := mapW;
  for i := 1 to mapH do
    for j := 1 to mapW do
      if ctWall in map[i, j] then
        CI.Pixels[i-1, j-1].FullColor := clBlack
      else
        CI.Pixels[i-1, j-1].FullColor := clWhite;
  DrawMap := CI.SaveToBitMap;
end;

end.

